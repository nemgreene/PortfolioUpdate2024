const images = require.context(
  "../../../Images/Portfolio/Projects/Basescripter",
  true
);
const imageList = images.keys().map((image) => images(image));

const structuredImages = [
  {
    src: imageList[0],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 1",
    title: "Intializing Project",
  },
  {
    src: imageList[1],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 2",
    title: "Using project hierarchy",
  },
  {
    src: imageList[2],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 3",
  },
  {
    src: imageList[3],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 4",
  },
  {
    src: imageList[4],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 5",
  },
  {
    src: imageList[5],
    priority: 1,
    cols: 12,
    alt: "Base Scripter Demo Image 6",
  },
];

export const BaseScripter = {
  images: structuredImages,
  description: {
    priority: 2,
    image: structuredImages[0],
    p: `Tool was developed to offer an development environment for Python scripting in Maya.
    
    Offering a lifecycle to support development without artifacts and a series of methods commonly used for scripting jobs. 
    
    This represents an ongoing body of development that supports my progress as a techincal artist

    PYTHON, MAYA
    `,
  },
  links: [
    { icon: "Github", src: "https://github.com/nemgreene/Pathfinder-Pymel" },
  ],

  blocks: [
    {
      priority: 0,
      images: [{ ...structuredImages[0], title: "Base Scripter" }],
    },

    {
      p: `This project offers a support tool to streamline my development proccess as a technical artist. During my time developing to date, patterns of steps that are used across projects have emerged that seem constant across many different types of scripts. 
      
      Implementing this BaseScripter project, I have made efforts to streamling those steps as much as possible, abstracting away repeated behavior into a helper class that can wrap my scripting development. 

      This tool is still in its alpha build, and continues to evolve in parallel with my proficiency. In time, I expect this project to follow me and underpin many of my future projects as it does my past. 

      I'll highlight a few of the most useful features here, full deocumentation will be available as the tool develops.
      `,
      priority: 1,
    },
    {
      p: `The initial concept for the tool origininated as a helper to manage project hierarchy, and enable scripts to be able to cleanup after themselves.

      At its simplest, the tool creates a group into which everything created by the script can be parented into. Every time the script is re-run, this group is deleted at the start of execution to make sure that the script can be run as many times as development demands without leaving any artifacts in the scene.

      Additional cleanup is included on run to remove anything from the scene generated by the previous execution that is not child to this group as well.
        `,
      priority: 2,
      images: [structuredImages[0]],
    },
    {
      priority: 2,
      images: [structuredImages[1]],
      p: `Once the project hierarchy is created, the tool can either use a method to make an object directly into the hierarchy, or parent it explicitly (see image). 

      The makeNested method from the class can either parent the created object to the root level of the project, or to a specific subfolder if created
        `,
    },
    {
      priority: 2,
      images: [structuredImages[2]],
      p: `More complex scripted rigs demand more complex hierarchies. The makeNesting method enables the tool to recursively create as complex a hierarchy as a rig can need. All groups created with this method also adhere to the defined naming convention (See Image).

      Using this method also creates a list of all the groups created for the hierarchy as seen in the image, that can be accessed programmatically from the tool.
      
      This illustrates one of the most important aims of the project, avoidi having to lookup objects by their strings, minimizing the possiblity for user error, and ensuring control over naming conventions.
        `,
    },
    {
      priority: 2,
      images: [structuredImages[3]],
      p: `Observing consistent naming conventions is important both for successful scripting and for keeping consistent results in Maya.

      The tool offers a method to help ensure this consistency and avoid messy string concatenation that is often endemic to pymel. Devs can use the nameGenerator method to quickly created the names to sign assets. 
      
      Notice (See Image) that the tool has a label that includes the side (for unilateral scripts, if needed) that should be included, ensuring cohesive naming convention.
        `,
    },
    {
      priority: 2,
      images: [structuredImages[4]],
      p: `An additional tool is included for constructing the strings that represent attribute names. This method becomes particularly useful in created networks of nodes created programatically. 

      Included is a simple script to show how these tools would be used in the development of a simple script:
      •	Make a rig hierarchy
      •	Create rig components
      •	Connect control to joint
        `,
    },
    {
      priority: 2,
      images: [structuredImages[5]],
      p: `The last method called will usually be the call to execute a chain of steps. Scripts are usually borken down to a chain of functions that are run consecutively. 
      
      This method runs them in a simple wrapper that will flag the name of the function that throws any errors, as well as cathing any CustomExceptions to allow developers to log specific errors
        `,
    },
  ],
};
